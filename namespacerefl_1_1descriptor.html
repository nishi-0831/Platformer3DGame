<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Game: refl::descriptor 名前空間</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Game
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacerefl_1_1descriptor.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">読み取り中…</div>
<div class="SRStatus" id="Searching">検索中…</div>
<div class="SRStatus" id="NoMatches">一致する文字列を見つけられません</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">名前空間</a> &#124;
<a href="#nested-classes">クラス</a> &#124;
<a href="#typedef-members">型定義</a> &#124;
<a href="#func-members">関数</a>  </div>
  <div class="headertitle"><div class="title">refl::descriptor 名前空間</div></div>
</div><!--header-->
<div class="contents">

<p>Contains the basic reflection primitives as well as functions operating on those primitives  
<a href="namespacerefl_1_1descriptor.html#details">[詳解]</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
名前空間</h2></td></tr>
<tr class="memitem:namespacerefl_1_1descriptor_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrefl_1_1descriptor_1_1field__descriptor.html">field_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a reflected field.  <a href="classrefl_1_1descriptor_1_1field__descriptor.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrefl_1_1descriptor_1_1function__descriptor.html">function_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a reflected function.  <a href="classrefl_1_1descriptor_1_1function__descriptor.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrefl_1_1descriptor_1_1member__descriptor__base.html">member_descriptor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base type for member descriptors.  <a href="classrefl_1_1descriptor_1_1member__descriptor__base.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrefl_1_1descriptor_1_1type__descriptor.html">type_descriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
型定義</h2></td></tr>
<tr class="memitem:a8c50bc8b2fa157709ed2453246d0f9a0"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="InputKeyCode_8h.html#a0607c9301fb39199343f886885e74574ab9ece18c950afbfa6b0fdbfa4ff731d3">T</a> &gt; </td></tr>
<tr class="memitem:a8c50bc8b2fa157709ed2453246d0f9a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a8c50bc8b2fa157709ed2453246d0f9a0">declared_member_list</a> = typename <a class="el" href="structrefl_1_1descriptor_1_1detail_1_1declared__member__list.html">detail::declared_member_list</a>&lt; <a class="el" href="InputKeyCode_8h.html#a0607c9301fb39199343f886885e74574ab9ece18c950afbfa6b0fdbfa4ff731d3">T</a> &gt;::type</td></tr>
<tr class="separator:a8c50bc8b2fa157709ed2453246d0f9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b88518840c2acd134a2171795bd7c3"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="InputKeyCode_8h.html#a0607c9301fb39199343f886885e74574ab9ece18c950afbfa6b0fdbfa4ff731d3">T</a> &gt; </td></tr>
<tr class="memitem:a50b88518840c2acd134a2171795bd7c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list</a> = typename <a class="el" href="structrefl_1_1descriptor_1_1detail_1_1member__list.html">detail::member_list</a>&lt; <a class="el" href="InputKeyCode_8h.html#a0607c9301fb39199343f886885e74574ab9ece18c950afbfa6b0fdbfa4ff731d3">T</a> &gt;::type</td></tr>
<tr class="separator:a50b88518840c2acd134a2171795bd7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b739222556b1550c354fe00fe7ed38"><td class="memTemplParams" colspan="2">template&lt;typename FunctionDescriptor , typename... Args&gt; </td></tr>
<tr class="memitem:a99b739222556b1550c354fe00fe7ed38"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a99b739222556b1550c354fe00fe7ed38">result_type</a> = typename FunctionDescriptor::template <a class="el" href="namespacerefl_1_1descriptor.html#a99b739222556b1550c354fe00fe7ed38">result_type</a>&lt; Args... &gt;</td></tr>
<tr class="separator:a99b739222556b1550c354fe00fe7ed38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
関数</h2></td></tr>
<tr class="memitem:aff945ef69bf77ab1725a5a8d4c1fea98"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:aff945ef69bf77ab1725a5a8d4c1fea98"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">get_name</a> (Descriptor d) noexcept</td></tr>
<tr class="separator:aff945ef69bf77ab1725a5a8d4c1fea98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebd2e485652249f5319310f3af3c3ae"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:abebd2e485652249f5319310f3af3c3ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#abebd2e485652249f5319310f3af3c3ae">get_attributes</a> (Descriptor d) noexcept</td></tr>
<tr class="separator:abebd2e485652249f5319310f3af3c3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ed2ffb6772717a47f526da332c45c8"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:a84ed2ffb6772717a47f526da332c45c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a84ed2ffb6772717a47f526da332c45c8">get_attribute_types</a> (Descriptor d) noexcept</td></tr>
<tr class="separator:a84ed2ffb6772717a47f526da332c45c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb250d284ee439d4307299a9cb22498c"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:acb250d284ee439d4307299a9cb22498c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#acb250d284ee439d4307299a9cb22498c">get_declared_base_types</a> (TypeDescriptor t) noexcept</td></tr>
<tr class="separator:acb250d284ee439d4307299a9cb22498c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc445cfd9be739891c2b6731047cf144"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:afc445cfd9be739891c2b6731047cf144"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#afc445cfd9be739891c2b6731047cf144">get_base_types</a> (TypeDescriptor t) noexcept</td></tr>
<tr class="separator:afc445cfd9be739891c2b6731047cf144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af716224744f34050b6b43a95251f750c"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:af716224744f34050b6b43a95251f750c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#af716224744f34050b6b43a95251f750c">get_declared_members</a> (TypeDescriptor t) noexcept</td></tr>
<tr class="separator:af716224744f34050b6b43a95251f750c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60741d56b2c28157b3588b7348256b7"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:ad60741d56b2c28157b3588b7348256b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#ad60741d56b2c28157b3588b7348256b7">get_members</a> (TypeDescriptor t) noexcept</td></tr>
<tr class="separator:ad60741d56b2c28157b3588b7348256b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe87e9035c9416033b3514aa094bc0fd"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:afe87e9035c9416033b3514aa094bc0fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#afe87e9035c9416033b3514aa094bc0fd">get_declarator</a> (MemberDescriptor d) noexcept</td></tr>
<tr class="separator:afe87e9035c9416033b3514aa094bc0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e6a5698114443414d43d3b4ae1c50c"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:a75e6a5698114443414d43d3b4ae1c50c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a75e6a5698114443414d43d3b4ae1c50c">get_pointer</a> (MemberDescriptor d) noexcept</td></tr>
<tr class="separator:a75e6a5698114443414d43d3b4ae1c50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17264f6fe5ef2e6f10a67304cb40e83"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor , typename... Args&gt; </td></tr>
<tr class="memitem:ab17264f6fe5ef2e6f10a67304cb40e83"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#ab17264f6fe5ef2e6f10a67304cb40e83">invoke</a> (MemberDescriptor d, Args &amp;&amp;... args) noexcept -&gt; decltype(d(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="separator:ab17264f6fe5ef2e6f10a67304cb40e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a133a31fb133920609bba17fad68b2"><td class="memTemplParams" colspan="2">template&lt;typename FieldDescriptor &gt; </td></tr>
<tr class="memitem:a19a133a31fb133920609bba17fad68b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a19a133a31fb133920609bba17fad68b2">is_static</a> (FieldDescriptor d) noexcept</td></tr>
<tr class="separator:a19a133a31fb133920609bba17fad68b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6127ab327b1e8f31062e9d0e2440a757"><td class="memTemplParams" colspan="2">template&lt;typename FieldDescriptor &gt; </td></tr>
<tr class="memitem:a6127ab327b1e8f31062e9d0e2440a757"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a6127ab327b1e8f31062e9d0e2440a757">is_const</a> (FieldDescriptor d) noexcept</td></tr>
<tr class="separator:a6127ab327b1e8f31062e9d0e2440a757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2afa6e939c641de9a9f184388341da"><td class="memTemplParams" colspan="2">template&lt;typename FunctionDescriptor &gt; </td></tr>
<tr class="memitem:a8d2afa6e939c641de9a9f184388341da"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a8d2afa6e939c641de9a9f184388341da">is_resolved</a> (FunctionDescriptor d) noexcept</td></tr>
<tr class="separator:a8d2afa6e939c641de9a9f184388341da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d6702622d06d0e2f5792f903626790"><td class="memTemplParams" colspan="2">template&lt;typename Pointer , typename FunctionDescriptor &gt; </td></tr>
<tr class="memitem:ad3d6702622d06d0e2f5792f903626790"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#ad3d6702622d06d0e2f5792f903626790">can_resolve</a> (FunctionDescriptor d) noexcept</td></tr>
<tr class="separator:ad3d6702622d06d0e2f5792f903626790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0a7b34d1892fffb8355aaeff29c750"><td class="memTemplParams" colspan="2">template&lt;typename Pointer , typename FunctionDescriptor &gt; </td></tr>
<tr class="memitem:a1a0a7b34d1892fffb8355aaeff29c750"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a1a0a7b34d1892fffb8355aaeff29c750">resolve</a> (FunctionDescriptor d) noexcept</td></tr>
<tr class="separator:a1a0a7b34d1892fffb8355aaeff29c750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1454a5c8702f245ceafaa9731026f7fe"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:a1454a5c8702f245ceafaa9731026f7fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a1454a5c8702f245ceafaa9731026f7fe">is_field</a> (Descriptor) noexcept</td></tr>
<tr class="separator:a1454a5c8702f245ceafaa9731026f7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76608e349f1f11d8e7eb5ccb759806a6"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:a76608e349f1f11d8e7eb5ccb759806a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a76608e349f1f11d8e7eb5ccb759806a6">is_function</a> (Descriptor) noexcept</td></tr>
<tr class="separator:a76608e349f1f11d8e7eb5ccb759806a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2665e32dba32044036fa66303c12aa"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:abe2665e32dba32044036fa66303c12aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#abe2665e32dba32044036fa66303c12aa">is_type</a> (Descriptor) noexcept</td></tr>
<tr class="separator:abe2665e32dba32044036fa66303c12aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024d98e2fa7e18a1d7ece243549cde68"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classA.html">A</a> , typename Descriptor &gt; </td></tr>
<tr class="memitem:a024d98e2fa7e18a1d7ece243549cde68"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a024d98e2fa7e18a1d7ece243549cde68">has_attribute</a> (Descriptor) noexcept</td></tr>
<tr class="separator:a024d98e2fa7e18a1d7ece243549cde68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0538bdbbc1881ccaa3e6d9a081550342"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classA.html">A</a> , typename Descriptor &gt; </td></tr>
<tr class="memitem:a0538bdbbc1881ccaa3e6d9a081550342"><td class="memTemplItemLeft" align="right" valign="top">constexpr const <a class="el" href="classA.html">A</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a0538bdbbc1881ccaa3e6d9a081550342">get_attribute</a> (Descriptor d) noexcept</td></tr>
<tr class="separator:a0538bdbbc1881ccaa3e6d9a081550342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4340f309b25037d0c5fca424202ad8e2"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; typename A, typename Descriptor &gt; </td></tr>
<tr class="memitem:a4340f309b25037d0c5fca424202ad8e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a4340f309b25037d0c5fca424202ad8e2">get_attribute</a> (Descriptor d) noexcept</td></tr>
<tr class="separator:a4340f309b25037d0c5fca424202ad8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288a833843be97b2d80b51b1de886f99"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:a288a833843be97b2d80b51b1de886f99"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a288a833843be97b2d80b51b1de886f99">is_property</a> (MemberDescriptor d) noexcept</td></tr>
<tr class="separator:a288a833843be97b2d80b51b1de886f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb1bb89c2469071ced6551ca3b9b8fd"><td class="memTemplParams" colspan="2">template&lt;typename FunctionDescriptor &gt; </td></tr>
<tr class="memitem:aadb1bb89c2469071ced6551ca3b9b8fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structrefl_1_1attr_1_1property.html">attr::property</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#aadb1bb89c2469071ced6551ca3b9b8fd">get_property</a> (FunctionDescriptor d) noexcept</td></tr>
<tr class="separator:aadb1bb89c2469071ced6551ca3b9b8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68bedab33d684ee5ee4ead24c5586ab"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:aa68bedab33d684ee5ee4ead24c5586ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab">is_readable</a> (MemberDescriptor) noexcept</td></tr>
<tr class="separator:aa68bedab33d684ee5ee4ead24c5586ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925e8cb99d6199fe03edeb5109958f8d"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:a925e8cb99d6199fe03edeb5109958f8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a925e8cb99d6199fe03edeb5109958f8d">is_writable</a> (MemberDescriptor) noexcept</td></tr>
<tr class="separator:a925e8cb99d6199fe03edeb5109958f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00126ab409dbc1a5445d37832876fe2"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:ac00126ab409dbc1a5445d37832876fe2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#ac00126ab409dbc1a5445d37832876fe2">has_bases</a> (TypeDescriptor t) noexcept</td></tr>
<tr class="separator:ac00126ab409dbc1a5445d37832876fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725c882cfae058b70d50517fe134a938"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:a725c882cfae058b70d50517fe134a938"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a725c882cfae058b70d50517fe134a938">get_bases</a> (TypeDescriptor t) noexcept</td></tr>
<tr class="separator:a725c882cfae058b70d50517fe134a938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5621e8b981bfb910f027fb720320f977"><td class="memTemplParams" colspan="2">template&lt;typename TypeDescriptor &gt; </td></tr>
<tr class="memitem:a5621e8b981bfb910f027fb720320f977"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a5621e8b981bfb910f027fb720320f977">get_simple_name</a> (TypeDescriptor t)</td></tr>
<tr class="separator:a5621e8b981bfb910f027fb720320f977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18162a39182126fc2345f2fe3e5b058"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:aa18162a39182126fc2345f2fe3e5b058"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#aa18162a39182126fc2345f2fe3e5b058">get_debug_name_const</a> (MemberDescriptor d)</td></tr>
<tr class="separator:aa18162a39182126fc2345f2fe3e5b058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8d4c897d931f5084e81fd61d3f966d"><td class="memTemplParams" colspan="2">template&lt;typename MemberDescriptor &gt; </td></tr>
<tr class="memitem:a9e8d4c897d931f5084e81fd61d3f966d"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a9e8d4c897d931f5084e81fd61d3f966d">get_debug_name</a> (MemberDescriptor d)</td></tr>
<tr class="separator:a9e8d4c897d931f5084e81fd61d3f966d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27554b892d20ba1fe45bc765aa3befcd"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:a27554b892d20ba1fe45bc765aa3befcd"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a27554b892d20ba1fe45bc765aa3befcd">get_display_name</a> (Descriptor d) noexcept</td></tr>
<tr class="separator:a27554b892d20ba1fe45bc765aa3befcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb65ca47183b468df2b8429dc5dea61"><td class="memTemplParams" colspan="2">template&lt;typename Descriptor &gt; </td></tr>
<tr class="memitem:a7cb65ca47183b468df2b8429dc5dea61"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a7cb65ca47183b468df2b8429dc5dea61">get_display_name_const</a> (Descriptor d) noexcept</td></tr>
<tr class="separator:a7cb65ca47183b468df2b8429dc5dea61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3677023906e7fb31d6267d4afdaeffde"><td class="memTemplParams" colspan="2">template&lt;typename ReadableMember &gt; </td></tr>
<tr class="memitem:a3677023906e7fb31d6267d4afdaeffde"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a3677023906e7fb31d6267d4afdaeffde">has_writer</a> (ReadableMember member)</td></tr>
<tr class="separator:a3677023906e7fb31d6267d4afdaeffde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d943ef351c700532badfa3c5d4ba953"><td class="memTemplParams" colspan="2">template&lt;typename WritableMember &gt; </td></tr>
<tr class="memitem:a3d943ef351c700532badfa3c5d4ba953"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a3d943ef351c700532badfa3c5d4ba953">has_reader</a> (WritableMember member)</td></tr>
<tr class="separator:a3d943ef351c700532badfa3c5d4ba953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cc337624b45bd2d5f9b27d6811fafd"><td class="memTemplParams" colspan="2">template&lt;typename ReadableMember &gt; </td></tr>
<tr class="memitem:ad4cc337624b45bd2d5f9b27d6811fafd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#ad4cc337624b45bd2d5f9b27d6811fafd">get_writer</a> (ReadableMember member)</td></tr>
<tr class="separator:ad4cc337624b45bd2d5f9b27d6811fafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3690f579517cc28e9d2eacb3d095fdbb"><td class="memTemplParams" colspan="2">template&lt;typename WritableMember &gt; </td></tr>
<tr class="memitem:a3690f579517cc28e9d2eacb3d095fdbb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerefl_1_1descriptor.html#a3690f579517cc28e9d2eacb3d095fdbb">get_reader</a> (WritableMember member)</td></tr>
<tr class="separator:a3690f579517cc28e9d2eacb3d095fdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>Contains the basic reflection primitives as well as functions operating on those primitives </p>
</div><h2 class="groupheader">型定義詳解</h2>
<a id="a8c50bc8b2fa157709ed2453246d0f9a0" name="a8c50bc8b2fa157709ed2453246d0f9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c50bc8b2fa157709ed2453246d0f9a0">&#9670;&#160;</a></span>declared_member_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="InputKeyCode_8h.html#a0607c9301fb39199343f886885e74574ab9ece18c950afbfa6b0fdbfa4ff731d3">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerefl_1_1descriptor.html#a8c50bc8b2fa157709ed2453246d0f9a0">refl::descriptor::declared_member_list</a> = typedef typename <a class="el" href="structrefl_1_1descriptor_1_1detail_1_1declared__member__list.html">detail::declared_member_list</a>&lt;<a class="el" href="InputKeyCode_8h.html#a0607c9301fb39199343f886885e74574ab9ece18c950afbfa6b0fdbfa4ff731d3">T</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classA.html">A</a> type_list of the declared member descriptors of the target type T. </p>

<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02332">2332</a> 行目に定義があります。</p>

</div>
</div>
<a id="a50b88518840c2acd134a2171795bd7c3" name="a50b88518840c2acd134a2171795bd7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b88518840c2acd134a2171795bd7c3">&#9670;&#160;</a></span>member_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="InputKeyCode_8h.html#a0607c9301fb39199343f886885e74574ab9ece18c950afbfa6b0fdbfa4ff731d3">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">refl::descriptor::member_list</a> = typedef typename <a class="el" href="structrefl_1_1descriptor_1_1detail_1_1member__list.html">detail::member_list</a>&lt;<a class="el" href="InputKeyCode_8h.html#a0607c9301fb39199343f886885e74574ab9ece18c950afbfa6b0fdbfa4ff731d3">T</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classA.html">A</a> type_list of the declared and inherited member descriptors of the target type T. </p>

<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02336">2336</a> 行目に定義があります。</p>

</div>
</div>
<a id="a99b739222556b1550c354fe00fe7ed38" name="a99b739222556b1550c354fe00fe7ed38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b739222556b1550c354fe00fe7ed38">&#9670;&#160;</a></span>result_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionDescriptor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerefl_1_1descriptor.html#a99b739222556b1550c354fe00fe7ed38">refl::descriptor::result_type</a> = typedef typename FunctionDescriptor::template <a class="el" href="namespacerefl_1_1descriptor.html#a99b739222556b1550c354fe00fe7ed38">result_type</a>&lt;Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The return type when invoking the specified descriptor using the provided argument types. Argument coversion will be applied as per C++ rules. </p>

<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02894">2894</a> 行目に定義があります。</p>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="ad3d6702622d06d0e2f5792f903626790" name="ad3d6702622d06d0e2f5792f903626790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d6702622d06d0e2f5792f903626790">&#9670;&#160;</a></span>can_resolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer , typename FunctionDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::can_resolve </td>
          <td>(</td>
          <td class="paramtype">FunctionDescriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the function pointer can be resolved as a pointer of the specified type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">void</span> bar();</div>
<div class="line">  <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>);</div>
<div class="line">};</div>
<div class="line">REFL_AUTO(type(Foo), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(bar))</div>
<div class="line">can_resolve&lt;void(Foo::*)()&gt;(get_t&lt;0, member_list&lt;Foo&gt;&gt;()) -&gt; <span class="keyword">true</span></div>
<div class="line">can_resolve&lt;void(Foo::*)(int)&gt;(get_t&lt;0, member_list&lt;Foo&gt;&gt;()) -&gt; <span class="keyword">true</span></div>
<div class="line">can_resolve&lt;void(Foo::*)(std::string)&gt;(get_t&lt;0, member_list&lt;Foo&gt;&gt;()) -&gt; <span class="keyword">false</span></div>
<div class="ttc" id="agroup__group1_html_ga24f647174760cac13d2624b5ad74b00c"><div class="ttname"><a href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a></div><div class="ttdeci">void func()</div><div class="ttdef"><b>Definition:</b> <a href="group_8cpp_source.html#l00013">group.cpp:13</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02933">2933</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2934</span>        {</div>
<div class="line"><span class="lineno"> 2935</span>            <span class="keyword">static_assert</span>(trait::is_function_v&lt;FunctionDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 2936</span>            <span class="keywordflow">return</span> d.template can_resolve&lt;Pointer&gt;();</div>
<div class="line"><span class="lineno"> 2937</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0538bdbbc1881ccaa3e6d9a081550342" name="a0538bdbbc1881ccaa3e6d9a081550342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0538bdbbc1881ccaa3e6d9a081550342">&#9670;&#160;</a></span>get_attribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classA.html">A</a> , typename Descriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="classA.html">A</a> &amp; refl::descriptor::get_attribute </td>
          <td>(</td>
          <td class="paramtype">Descriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the attribute <a class="el" href="classA.html">A</a> on T.</p>
<div class="fragment"><div class="line">REFL_AUTO(type(User), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">get_name</a>, property()), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(set_name, property()))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a0538bdbbc1881ccaa3e6d9a081550342">get_attribute</a>&lt;attr::property&gt;(get_t&lt;0, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list</a>&lt;User&gt;&gt;{}) -&gt; property{ friendly_name = nullopt }</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a0538bdbbc1881ccaa3e6d9a081550342"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a0538bdbbc1881ccaa3e6d9a081550342">refl::descriptor::get_attribute</a></div><div class="ttdeci">constexpr const A &amp; get_attribute(Descriptor d) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03052">refl.hpp:3052</a></div></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a50b88518840c2acd134a2171795bd7c3"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">refl::descriptor::member_list</a></div><div class="ttdeci">typename detail::member_list&lt; T &gt;::type member_list</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02336">refl.hpp:2336</a></div></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_aff945ef69bf77ab1725a5a8d4c1fea98"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">refl::descriptor::get_name</a></div><div class="ttdeci">constexpr auto get_name(Descriptor d) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02655">refl.hpp:2655</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03052">3052</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3053</span>        {</div>
<div class="line"><span class="lineno"> 3054</span>            <span class="keyword">static_assert</span>(trait::is_descriptor_v&lt;Descriptor&gt;);</div>
<div class="line"><span class="lineno"> 3055</span>            <span class="keywordflow">return</span> util::get&lt;A&gt;(d.attributes);</div>
<div class="line"><span class="lineno"> 3056</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4340f309b25037d0c5fca424202ad8e2" name="a4340f309b25037d0c5fca424202ad8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4340f309b25037d0c5fca424202ad8e2">&#9670;&#160;</a></span>get_attribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; typename A, typename Descriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const auto &amp; refl::descriptor::get_attribute </td>
          <td>(</td>
          <td class="paramtype">Descriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the attribute <a class="el" href="classA.html">A</a> on T.</p>
<div class="fragment"><div class="line">REFL_AUTO(type(Random, debug{ [](<span class="keyword">auto</span> os, <span class="keyword">auto</span>){ os &lt;&lt; <span class="stringliteral">&quot;[Random]&quot;</span>; } }))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a0538bdbbc1881ccaa3e6d9a081550342">get_attribute</a>&lt;attr::debug&gt;(<a class="code hl_function" href="namespacerefl.html#a86dba5a377d375a2d28b60d16b185e2c">reflect</a>&lt;Random&gt;()) -&gt; instance of debug&lt;LambdaType&gt;</div>
<div class="ttc" id="anamespacerefl_html_a86dba5a377d375a2d28b60d16b185e2c"><div class="ttname"><a href="namespacerefl.html#a86dba5a377d375a2d28b60d16b185e2c">refl::reflect</a></div><div class="ttdeci">constexpr type_descriptor&lt; T &gt; reflect() noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03682">refl.hpp:3682</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03067">3067</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3068</span>        {</div>
<div class="line"><span class="lineno"> 3069</span>            <span class="keyword">static_assert</span>(trait::is_descriptor_v&lt;Descriptor&gt;);</div>
<div class="line"><span class="lineno"> 3070</span>            <span class="keywordflow">return</span> util::get_instance&lt;A&gt;(d.attributes);</div>
<div class="line"><span class="lineno"> 3071</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a84ed2ffb6772717a47f526da332c45c8" name="a84ed2ffb6772717a47f526da332c45c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ed2ffb6772717a47f526da332c45c8">&#9670;&#160;</a></span>get_attribute_types()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Descriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_attribute_types </td>
          <td>(</td>
          <td class="paramtype">Descriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a type_list of the descriptor's attribute types.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {};</div>
<div class="line">REFL_AUTO(type(Foo, bases&lt;&gt;, ns::serializable()))</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a84ed2ffb6772717a47f526da332c45c8">get_attribute_types</a>(<a class="code hl_function" href="namespacerefl.html#a86dba5a377d375a2d28b60d16b185e2c">reflect</a>&lt;Foo&gt;()) -&gt; <a class="code hl_struct" href="structrefl_1_1util_1_1type__list.html">type_list</a>&lt;attr::base_types&lt;&gt;, ns::serializable&gt;</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a84ed2ffb6772717a47f526da332c45c8"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a84ed2ffb6772717a47f526da332c45c8">refl::descriptor::get_attribute_types</a></div><div class="ttdeci">constexpr auto get_attribute_types(Descriptor d) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02689">refl.hpp:2689</a></div></div>
<div class="ttc" id="astructrefl_1_1util_1_1type__list_html"><div class="ttname"><a href="structrefl_1_1util_1_1type__list.html">refl::util::type_list</a></div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l00442">refl.hpp:443</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02689">2689</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2690</span>        {</div>
<div class="line"><span class="lineno"> 2691</span>            <span class="keyword">static_assert</span>(trait::is_descriptor_v&lt;Descriptor&gt;);</div>
<div class="line"><span class="lineno"> 2692</span>            <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespacerefl_1_1trait.html#ae2279db43338368acb8af9ade961a504">trait::as_type_list_t</a>&lt;std::remove_cv_t&lt;<span class="keyword">decltype</span>(d.attributes)&gt;&gt;{};</div>
<div class="line"><span class="lineno"> 2693</span>        }</div>
<div class="ttc" id="anamespacerefl_1_1trait_html_ae2279db43338368acb8af9ade961a504"><div class="ttname"><a href="namespacerefl_1_1trait.html#ae2279db43338368acb8af9ade961a504">refl::trait::as_type_list_t</a></div><div class="ttdeci">typename as_type_list&lt; T &gt;::type as_type_list_t</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l00859">refl.hpp:859</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abebd2e485652249f5319310f3af3c3ae" name="abebd2e485652249f5319310f3af3c3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebd2e485652249f5319310f3af3c3ae">&#9670;&#160;</a></span>get_attributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Descriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const auto &amp; refl::descriptor::get_attributes </td>
          <td>(</td>
          <td class="paramtype">Descriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to the descriptor's attribute tuple.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {};</div>
<div class="line">REFL_AUTO(type(Foo, bases&lt;&gt;, ns::serializable()))</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#abebd2e485652249f5319310f3af3c3ae">get_attributes</a>(<a class="code hl_function" href="namespacerefl.html#a86dba5a377d375a2d28b60d16b185e2c">reflect</a>&lt;Foo&gt;()) -&gt; const std::tuple&lt;attr::base_types&lt;&gt;, ns::serializable&gt;&amp;</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_abebd2e485652249f5319310f3af3c3ae"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#abebd2e485652249f5319310f3af3c3ae">refl::descriptor::get_attributes</a></div><div class="ttdeci">constexpr const auto &amp; get_attributes(Descriptor d) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02672">refl.hpp:2672</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02672">2672</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2673</span>        {</div>
<div class="line"><span class="lineno"> 2674</span>            <span class="keyword">static_assert</span>(trait::is_descriptor_v&lt;Descriptor&gt;);</div>
<div class="line"><span class="lineno"> 2675</span>            <span class="keywordflow">return</span> d.attributes;</div>
<div class="line"><span class="lineno"> 2676</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afc445cfd9be739891c2b6731047cf144" name="afc445cfd9be739891c2b6731047cf144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc445cfd9be739891c2b6731047cf144">&#9670;&#160;</a></span>get_base_types()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_base_types </td>
          <td>(</td>
          <td class="paramtype">TypeDescriptor&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a type_list of the declared and inherited base types of the type. Combine with reflect_types to obtain type_descriptors for those types. </p><dl class="section see"><dt>参照</dt><dd>reflect_types</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Animal {};</div>
<div class="line">REFL_AUTO(type(Animal))</div>
<div class="line"><span class="keyword">struct </span>Mammal : Animal {};</div>
<div class="line">REFL_AUTO(type(Mammal, bases&lt;Animal&gt;))</div>
<div class="line"><span class="keyword">struct </span>Dog : Mammal {}:</div>
<div class="line">REFL_AUTO(type(Dog, bases&lt;Mammal&gt;))</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#afc445cfd9be739891c2b6731047cf144">get_base_types</a>(reflect&lt;Dog&gt;()) -&gt; type_list&lt;Mammal, Animal&gt;</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_afc445cfd9be739891c2b6731047cf144"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#afc445cfd9be739891c2b6731047cf144">refl::descriptor::get_base_types</a></div><div class="ttdeci">constexpr auto get_base_types(TypeDescriptor t) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02735">refl.hpp:2735</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02735">2735</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2736</span>        {</div>
<div class="line"><span class="lineno"> 2737</span>            <span class="keyword">static_assert</span>(trait::is_type_v&lt;TypeDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 2738</span>            <span class="keywordflow">return</span> t.bases;</div>
<div class="line"><span class="lineno"> 2739</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a725c882cfae058b70d50517fe134a938" name="a725c882cfae058b70d50517fe134a938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725c882cfae058b70d50517fe134a938">&#9670;&#160;</a></span>get_bases()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_bases </td>
          <td>(</td>
          <td class="paramtype">TypeDescriptor&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a list of the type_descriptor&lt;T&gt;s of the base types of the target, as specified by the bases&lt;A, B, ...&gt; attribute.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">非推奨:</a></b></dt><dd>Use get_base_types in combination with reflect_types instead. </dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacerefl_1_1attr.html#a4a28906fa1330c1e8df39e6ccd4d9c19">refl::attr::bases</a> </dd>
<dd>
<a class="el" href="namespacerefl_1_1descriptor.html#ac00126ab409dbc1a5445d37832876fe2">refl::descriptor::has_bases</a></dd></dl>
<div class="fragment"><div class="line">REFL_AUTO(type(Dog, bases&lt;Animal&gt;))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a725c882cfae058b70d50517fe134a938">get_bases</a>(reflect&lt;Dog&gt;()) -&gt; <a class="code hl_struct" href="structrefl_1_1util_1_1type__list.html">type_list&lt;type_descriptor&lt;Animal&gt;</a>&gt;</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a725c882cfae058b70d50517fe134a938"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a725c882cfae058b70d50517fe134a938">refl::descriptor::get_bases</a></div><div class="ttdeci">constexpr auto get_bases(TypeDescriptor t) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03212">refl.hpp:3212</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03212">3212</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3213</span>        {</div>
<div class="line"><span class="lineno"> 3214</span>            <span class="keyword">static_assert</span>(trait::is_type_v&lt;TypeDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 3215</span>            <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#ac00126ab409dbc1a5445d37832876fe2">has_bases</a>(t), <span class="stringliteral">&quot;Target type does not have a bases&lt;A, B, ...&gt; attribute.&quot;</span>);</div>
<div class="line"><span class="lineno"> 3216</span> </div>
<div class="line"><span class="lineno"> 3217</span>            <span class="keyword">constexpr</span> <span class="keyword">auto</span> bases = get_attribute&lt;attr::base_types&gt;(t);</div>
<div class="line"><span class="lineno"> 3218</span>            <span class="keyword">using </span>base_types = <span class="keyword">typename</span> <span class="keyword">decltype</span>(bases)::list_type;</div>
<div class="line"><span class="lineno"> 3219</span>            <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespacerefl_1_1trait.html#a27b580a856a2aedc8487f28a4ded1c03">trait::map_t&lt;detail::get_type_descriptor, base_types&gt;</a>{};</div>
<div class="line"><span class="lineno"> 3220</span>        }</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_ac00126ab409dbc1a5445d37832876fe2"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#ac00126ab409dbc1a5445d37832876fe2">refl::descriptor::has_bases</a></div><div class="ttdeci">constexpr auto has_bases(TypeDescriptor t) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03192">refl.hpp:3192</a></div></div>
<div class="ttc" id="anamespacerefl_1_1trait_html_a27b580a856a2aedc8487f28a4ded1c03"><div class="ttname"><a href="namespacerefl_1_1trait.html#a27b580a856a2aedc8487f28a4ded1c03">refl::trait::map_t</a></div><div class="ttdeci">typename map&lt; Mapper, Ts... &gt;::type map_t</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l01188">refl.hpp:1188</a></div></div>
</div><!-- fragment -->
<p class="reference">参照先 <a class="el" href="refl_8hpp_source.html#l03192">has_bases()</a>.</p>
<div class="dynheader">
呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a725c882cfae058b70d50517fe134a938_cgraph.svg" width="351" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9e8d4c897d931f5084e81fd61d3f966d" name="a9e8d4c897d931f5084e81fd61d3f966d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8d4c897d931f5084e81fd61d3f966d">&#9670;&#160;</a></span>get_debug_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemberDescriptor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * refl::descriptor::get_debug_name </td>
          <td>(</td>
          <td class="paramtype">MemberDescriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the debug name of T. (In the form of 'declaring_type::member_name'). </p><div class="fragment"><div class="line">REFL_AUTO(type(Point), field(x), field(y))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a9e8d4c897d931f5084e81fd61d3f966d">get_debug_name</a>(get_t&lt;0, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list&lt;Point&gt;</a>&gt;{}) -&gt; <span class="stringliteral">&quot;Point::x&quot;</span></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a9e8d4c897d931f5084e81fd61d3f966d"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a9e8d4c897d931f5084e81fd61d3f966d">refl::descriptor::get_debug_name</a></div><div class="ttdeci">const char * get_debug_name(MemberDescriptor d)</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03266">refl.hpp:3266</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03266">3266</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3267</span>        {</div>
<div class="line"><span class="lineno"> 3268</span>            <span class="keyword">static_assert</span>(trait::is_member_v&lt;MemberDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 3269</span>            <span class="keyword">static</span> <span class="keyword">const</span> std::string name(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#aa18162a39182126fc2345f2fe3e5b058">get_debug_name_const</a>(d).str());</div>
<div class="line"><span class="lineno"> 3270</span>            <span class="keywordflow">return</span> name.c_str();</div>
<div class="line"><span class="lineno"> 3271</span>        }</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_aa18162a39182126fc2345f2fe3e5b058"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#aa18162a39182126fc2345f2fe3e5b058">refl::descriptor::get_debug_name_const</a></div><div class="ttdeci">constexpr auto get_debug_name_const(MemberDescriptor d)</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03252">refl.hpp:3252</a></div></div>
</div><!-- fragment -->
<p class="reference">参照先 <a class="el" href="refl_8hpp_source.html#l03252">get_debug_name_const()</a>.</p>
<div class="dynheader">
呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a9e8d4c897d931f5084e81fd61d3f966d_cgraph.svg" width="359" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa18162a39182126fc2345f2fe3e5b058" name="aa18162a39182126fc2345f2fe3e5b058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18162a39182126fc2345f2fe3e5b058">&#9670;&#160;</a></span>get_debug_name_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemberDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_debug_name_const </td>
          <td>(</td>
          <td class="paramtype">MemberDescriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the debug name of T (In the form of 'declaring_type::member_name') as a const_string.</p>
<div class="fragment"><div class="line">REFL_AUTO(type(Point), field(x), field(y))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#aa18162a39182126fc2345f2fe3e5b058">get_debug_name_const</a>(get_t&lt;0, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list&lt;Point&gt;</a>&gt;{}) -&gt; <span class="stringliteral">&quot;Point::x&quot;</span></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03252">3252</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3253</span>        {</div>
<div class="line"><span class="lineno"> 3254</span>            <span class="keyword">static_assert</span>(trait::is_member_v&lt;MemberDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 3255</span>            <span class="keywordflow">return</span> d.declarator.name + <span class="stringliteral">&quot;::&quot;</span> + d.name;</div>
<div class="line"><span class="lineno"> 3256</span>        }</div>
</div><!-- fragment -->
<p class="reference">参照元 <a class="el" href="refl_8hpp_source.html#l03266">get_debug_name()</a>.</p>
<div class="dynheader">
被呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_aa18162a39182126fc2345f2fe3e5b058_icgraph.svg" width="359" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afe87e9035c9416033b3514aa094bc0fd" name="afe87e9035c9416033b3514aa094bc0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe87e9035c9416033b3514aa094bc0fd">&#9670;&#160;</a></span>get_declarator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemberDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_declarator </td>
          <td>(</td>
          <td class="paramtype">MemberDescriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classrefl_1_1descriptor_1_1type__descriptor.html">type_descriptor</a> of declaring type of the member.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">int</span> bar;</div>
<div class="line">};</div>
<div class="line">REFL_AUTO(type(Foo), field(bar)</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#afe87e9035c9416033b3514aa094bc0fd">get_declarator</a>(get_t&lt;0, member_list&lt;Foo&gt;&gt;()) -&gt; <a class="code hl_class" href="classrefl_1_1descriptor_1_1type__descriptor.html">type_descriptor&lt;Foo&gt;</a>{}</div>
<div class="ttc" id="aclassrefl_1_1descriptor_1_1type__descriptor_html"><div class="ttname"><a href="classrefl_1_1descriptor_1_1type__descriptor.html">refl::descriptor::type_descriptor</a></div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02549">refl.hpp:2550</a></div></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_afe87e9035c9416033b3514aa094bc0fd"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#afe87e9035c9416033b3514aa094bc0fd">refl::descriptor::get_declarator</a></div><div class="ttdeci">constexpr auto get_declarator(MemberDescriptor d) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02795">refl.hpp:2795</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02795">2795</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2796</span>        {</div>
<div class="line"><span class="lineno"> 2797</span>            <span class="keyword">static_assert</span>(trait::is_member_v&lt;MemberDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 2798</span>            <span class="keywordflow">return</span> d.declarator;</div>
<div class="line"><span class="lineno"> 2799</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="acb250d284ee439d4307299a9cb22498c" name="acb250d284ee439d4307299a9cb22498c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb250d284ee439d4307299a9cb22498c">&#9670;&#160;</a></span>get_declared_base_types()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_declared_base_types </td>
          <td>(</td>
          <td class="paramtype">TypeDescriptor&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a type_list of the declared base types of the type. Combine with reflect_types to obtain type_descriptors for those types. </p><dl class="section see"><dt>参照</dt><dd>reflect_types</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Animal {};</div>
<div class="line">REFL_AUTO(type(Animal))</div>
<div class="line"><span class="keyword">struct </span>Mammal : Animal {};</div>
<div class="line">REFL_AUTO(type(Mammal, bases&lt;Animal&gt;))</div>
<div class="line"><span class="keyword">struct </span>Dog : Mammal {}:</div>
<div class="line">REFL_AUTO(type(Dog, bases&lt;Mammal&gt;))</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#afc445cfd9be739891c2b6731047cf144">get_base_types</a>(reflect&lt;Dog&gt;()) -&gt; type_list&lt;Mammal&gt;</div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02712">2712</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2713</span>        {</div>
<div class="line"><span class="lineno"> 2714</span>            <span class="keyword">static_assert</span>(trait::is_type_v&lt;TypeDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 2715</span>            <span class="keywordflow">return</span> t.declared_bases;</div>
<div class="line"><span class="lineno"> 2716</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af716224744f34050b6b43a95251f750c" name="af716224744f34050b6b43a95251f750c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af716224744f34050b6b43a95251f750c">&#9670;&#160;</a></span>get_declared_members()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_declared_members </td>
          <td>(</td>
          <td class="paramtype">TypeDescriptor&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a type_list of the declared members of the type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Base {</div>
<div class="line"> <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Foo : Base {</div>
<div class="line">  <span class="keywordtype">int</span> bar, baz;</div>
<div class="line">};</div>
<div class="line">REFL_AUTO(type(Foo, bases&lt;Base&gt;), field(bar), field(baz))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#af716224744f34050b6b43a95251f750c">get_declared_members</a>(reflect&lt;Foo&gt;()) -&gt; type_list&lt;field_descriptor&lt;Foo, 0&gt; /bar/, field_descriptor&lt;Foo, 1&gt; /baz/&gt;</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_af716224744f34050b6b43a95251f750c"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#af716224744f34050b6b43a95251f750c">refl::descriptor::get_declared_members</a></div><div class="ttdeci">constexpr auto get_declared_members(TypeDescriptor t) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02756">refl.hpp:2756</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02756">2756</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2757</span>        {</div>
<div class="line"><span class="lineno"> 2758</span>            <span class="keyword">static_assert</span>(trait::is_type_v&lt;TypeDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 2759</span>            <span class="keywordflow">return</span> t.declared_members;</div>
<div class="line"><span class="lineno"> 2760</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a27554b892d20ba1fe45bc765aa3befcd" name="a27554b892d20ba1fe45bc765aa3befcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27554b892d20ba1fe45bc765aa3befcd">&#9670;&#160;</a></span>get_display_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Descriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * refl::descriptor::get_display_name </td>
          <td>(</td>
          <td class="paramtype">Descriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the display name of T. Uses the friendly_name of the property attribute, or the normalized name if no friendly_name was provided.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">int</span> get_foo() <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">int</span> GetFoo() <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">int</span> get_non_const() /missing <span class="keyword">const</span>/;</div>
<div class="line">  <span class="keywordtype">int</span> get_custom() <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line">REFL_AUTO(</div>
<div class="line">  type(Foo),</div>
<div class="line">  <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(get_foo, property()),</div>
<div class="line">  <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(GetFoo, property()),</div>
<div class="line">  <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(get_non_const, property()),</div>
<div class="line">  <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(get_custom, property(<span class="stringliteral">&quot;value&quot;</span>)),</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a27554b892d20ba1fe45bc765aa3befcd">get_display_name</a>(get_t&lt;0, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list</a>&lt;Foo&gt;&gt;{}) -&gt; <span class="stringliteral">&quot;foo&quot;</span></div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a27554b892d20ba1fe45bc765aa3befcd">get_display_name</a>(get_t&lt;1, member_list&lt;Foo&gt;&gt;{}) -&gt; <span class="stringliteral">&quot;Foo&quot;</span></div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a27554b892d20ba1fe45bc765aa3befcd">get_display_name</a>(get_t&lt;2, member_list&lt;Foo&gt;&gt;{}) -&gt; <span class="stringliteral">&quot;get_non_const&quot;</span></div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a27554b892d20ba1fe45bc765aa3befcd">get_display_name</a>(get_t&lt;3, member_list&lt;Foo&gt;&gt;{}) -&gt; <span class="stringliteral">&quot;value&quot;</span></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a27554b892d20ba1fe45bc765aa3befcd"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a27554b892d20ba1fe45bc765aa3befcd">refl::descriptor::get_display_name</a></div><div class="ttdeci">const char * get_display_name(Descriptor d) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03453">refl.hpp:3453</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03453">3453</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3454</span>        {</div>
<div class="line"><span class="lineno"> 3455</span>            <span class="keyword">static_assert</span>(trait::is_descriptor_v&lt;Descriptor&gt;);</div>
<div class="line"><span class="lineno"> 3456</span>            <span class="keyword">static</span> <span class="keyword">const</span> std::string name(detail::get_display_name(d));</div>
<div class="line"><span class="lineno"> 3457</span>            <span class="keywordflow">return</span> name.c_str();</div>
<div class="line"><span class="lineno"> 3458</span>        }</div>
</div><!-- fragment -->
<p class="reference">参照先 <a class="el" href="refl_8hpp_source.html#l03336">refl::descriptor::detail::get_display_name()</a>.</p>

<p class="reference">参照元 <a class="el" href="JsonConverter_8h_source.html#l00089">JsonConverter::Serialize()</a>.</p>
<div class="dynheader">
呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a27554b892d20ba1fe45bc765aa3befcd_cgraph.svg" width="826" height="179"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
被呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a27554b892d20ba1fe45bc765aa3befcd_icgraph.svg" width="382" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7cb65ca47183b468df2b8429dc5dea61" name="a7cb65ca47183b468df2b8429dc5dea61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb65ca47183b468df2b8429dc5dea61">&#9670;&#160;</a></span>get_display_name_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Descriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_display_name_const </td>
          <td>(</td>
          <td class="paramtype">Descriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the display name of T as a const_string&lt;N&gt;. Uses the friendly_name of the property attribute, or the normalized name if no friendly_name was provided. </p><dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacerefl_1_1descriptor.html#a27554b892d20ba1fe45bc765aa3befcd">get_display_name</a> </dd></dl>

<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03466">3466</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3467</span>        {</div>
<div class="line"><span class="lineno"> 3468</span>            <span class="keyword">static_assert</span>(trait::is_descriptor_v&lt;Descriptor&gt;);</div>
<div class="line"><span class="lineno"> 3469</span>            <span class="keywordflow">return</span> detail::get_display_name(d);</div>
<div class="line"><span class="lineno"> 3470</span>        }</div>
</div><!-- fragment -->
<p class="reference">参照先 <a class="el" href="refl_8hpp_source.html#l03336">refl::descriptor::detail::get_display_name()</a>.</p>

<p class="reference">参照元 <a class="el" href="refl_8hpp_source.html#l03617">get_reader()</a>, <a class="el" href="refl_8hpp_source.html#l03569">get_writer()</a>, <a class="el" href="refl_8hpp_source.html#l03524">has_reader()</a>, <a class="el" href="refl_8hpp_source.html#l03479">has_writer()</a>.</p>
<div class="dynheader">
呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a7cb65ca47183b468df2b8429dc5dea61_cgraph.svg" width="843" height="179"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
被呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a7cb65ca47183b468df2b8429dc5dea61_icgraph.svg" width="562" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad60741d56b2c28157b3588b7348256b7" name="ad60741d56b2c28157b3588b7348256b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60741d56b2c28157b3588b7348256b7">&#9670;&#160;</a></span>get_members()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_members </td>
          <td>(</td>
          <td class="paramtype">TypeDescriptor&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a type_list of the declared and inherited members of the type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Base {</div>
<div class="line"> <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Foo : Base {</div>
<div class="line">  <span class="keywordtype">int</span> bar, baz;</div>
<div class="line">};</div>
<div class="line">REFL_AUTO(type(Foo, bases&lt;Base&gt;), field(bar), field(baz))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#ad60741d56b2c28157b3588b7348256b7">get_members</a>(reflect&lt;Foo&gt;()) -&gt; type_list&lt;field_descriptor&lt;Foo, 0&gt; /bar/, field_descriptor&lt;Foo, 1&gt; /baz/, field_descriptor&lt;Base, 0&gt; /val/&gt;</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_ad60741d56b2c28157b3588b7348256b7"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#ad60741d56b2c28157b3588b7348256b7">refl::descriptor::get_members</a></div><div class="ttdeci">constexpr auto get_members(TypeDescriptor t) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02777">refl.hpp:2777</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02777">2777</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2778</span>        {</div>
<div class="line"><span class="lineno"> 2779</span>            <span class="keyword">static_assert</span>(trait::is_type_v&lt;TypeDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 2780</span>            <span class="keywordflow">return</span> t.members;</div>
<div class="line"><span class="lineno"> 2781</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aff945ef69bf77ab1725a5a8d4c1fea98" name="aff945ef69bf77ab1725a5a8d4c1fea98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff945ef69bf77ab1725a5a8d4c1fea98">&#9670;&#160;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Descriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_name </td>
          <td>(</td>
          <td class="paramtype">Descriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the full name of the descriptor</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>ns {</div>
<div class="line">  <span class="keyword">struct </span>Foo {</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line">REFL_AUTO(type(ns::Foo), field(x))</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">get_name</a>(reflect&lt;Foo&gt;()) -&gt; <span class="stringliteral">&quot;ns::Foo&quot;</span></div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">get_name</a>(get_t&lt;0, member_list&lt;Foo&gt;&gt;()) -&gt; <span class="stringliteral">&quot;x&quot;</span></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02655">2655</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2656</span>        {</div>
<div class="line"><span class="lineno"> 2657</span>            <span class="keyword">static_assert</span>(trait::is_descriptor_v&lt;Descriptor&gt;);</div>
<div class="line"><span class="lineno"> 2658</span>            <span class="keywordflow">return</span> d.name;</div>
<div class="line"><span class="lineno"> 2659</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a75e6a5698114443414d43d3b4ae1c50c" name="a75e6a5698114443414d43d3b4ae1c50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e6a5698114443414d43d3b4ae1c50c">&#9670;&#160;</a></span>get_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemberDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_pointer </td>
          <td>(</td>
          <td class="paramtype">MemberDescriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the reflected field/function. When the member is a function, the return value might be nullptr if the type of the function pointer cannot be resolved. </p><dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacerefl_1_1descriptor.html#a8d2afa6e939c641de9a9f184388341da">is_resolved</a> </dd>
<dd>
<a class="el" href="namespacerefl_1_1descriptor.html#ad3d6702622d06d0e2f5792f903626790">can_resolve</a> </dd>
<dd>
<a class="el" href="namespacerefl_1_1descriptor.html#a1a0a7b34d1892fffb8355aaeff29c750">resolve</a></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">int</span> bar;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> baz;</div>
<div class="line">};</div>
<div class="line">REFL_AUTO(type(Foo), field(bar), field(baz))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a75e6a5698114443414d43d3b4ae1c50c">get_pointer</a>(get_t&lt;0, member_list&lt;Foo&gt;&gt;()) -&gt; (<span class="keywordtype">int</span> Foo::*) &amp;Foo::bar</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a75e6a5698114443414d43d3b4ae1c50c">get_pointer</a>(get_t&lt;1, member_list&lt;Foo&gt;&gt;()) -&gt; (<span class="keywordtype">int</span>*) &amp;Foo::baz</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a75e6a5698114443414d43d3b4ae1c50c"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a75e6a5698114443414d43d3b4ae1c50c">refl::descriptor::get_pointer</a></div><div class="ttdeci">constexpr auto get_pointer(MemberDescriptor d) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02820">refl.hpp:2820</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02820">2820</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2821</span>        {</div>
<div class="line"><span class="lineno"> 2822</span>            <span class="keyword">static_assert</span>(trait::is_member_v&lt;MemberDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 2823</span>            <span class="keywordflow">return</span> d.pointer;</div>
<div class="line"><span class="lineno"> 2824</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aadb1bb89c2469071ced6551ca3b9b8fd" name="aadb1bb89c2469071ced6551ca3b9b8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb1bb89c2469071ced6551ca3b9b8fd">&#9670;&#160;</a></span>get_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structrefl_1_1attr_1_1property.html">attr::property</a> refl::descriptor::get_property </td>
          <td>(</td>
          <td class="paramtype">FunctionDescriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the property attribute.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="structrefl_1_1attr_1_1property.html">refl::attr::property</a> </dd>
<dd>
<a class="el" href="namespacerefl_1_1descriptor.html#a288a833843be97b2d80b51b1de886f99">refl::descriptor::is_property</a></dd></dl>
<div class="fragment"><div class="line">REFL_AUTO(type(User), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">get_name</a>, property(<span class="stringliteral">&quot;user_name&quot;</span>)), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(set_name, property()))</div>
<div class="line">*<a class="code hl_function" href="namespacerefl_1_1descriptor.html#aadb1bb89c2469071ced6551ca3b9b8fd">get_property</a>(get_t&lt;0, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list&lt;User&gt;</a>&gt;{}).friendly_name -&gt; <span class="stringliteral">&quot;user_name&quot;</span></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_aadb1bb89c2469071ced6551ca3b9b8fd"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#aadb1bb89c2469071ced6551ca3b9b8fd">refl::descriptor::get_property</a></div><div class="ttdeci">constexpr attr::property get_property(FunctionDescriptor d) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03103">refl.hpp:3103</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03103">3103</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3104</span>        {</div>
<div class="line"><span class="lineno"> 3105</span>            <span class="keyword">static_assert</span>(trait::is_function_v&lt;FunctionDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 3106</span>            <span class="keywordflow">return</span> get_attribute&lt;attr::property&gt;(d);</div>
<div class="line"><span class="lineno"> 3107</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3690f579517cc28e9d2eacb3d095fdbb" name="a3690f579517cc28e9d2eacb3d095fdbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3690f579517cc28e9d2eacb3d095fdbb">&#9670;&#160;</a></span>get_reader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WritableMember &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_reader </td>
          <td>(</td>
          <td class="paramtype">WritableMember&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a member that has the same display name as the one provied and is readable. For setter methods with a property attribute, the return value will be a reflected getter method with a property with the same display name (property name normalization applies automatically). For fields, returns the same descriptor. </p>

<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03617">3617</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3618</span>        {</div>
<div class="line"><span class="lineno"> 3619</span>            <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab">is_readable</a>(member) || <a class="code hl_function" href="namespacerefl_1_1descriptor.html#a288a833843be97b2d80b51b1de886f99">is_property</a>(member));</div>
<div class="line"><span class="lineno"> 3620</span>            <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_function" href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab">is_readable</a>(member)) {</div>
<div class="line"><span class="lineno"> 3621</span>                <span class="keywordflow">return</span> member;</div>
<div class="line"><span class="lineno"> 3622</span>            }</div>
<div class="line"><span class="lineno"> 3623</span>            <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (has_reader(member)) {</div>
<div class="line"><span class="lineno"> 3624</span>                <span class="keyword">constexpr</span> <span class="keyword">auto</span> match = [](<span class="keyword">auto</span> m) {</div>
<div class="line"><span class="lineno"> 3625</span>                    <span class="keywordflow">return</span> is_property(m) &amp;&amp; is_readable(m) &amp;&amp; get_display_name_const(m) == get_display_name_const(WritableMember{});</div>
<div class="line"><span class="lineno"> 3626</span>                };</div>
<div class="line"><span class="lineno"> 3627</span> </div>
<div class="line"><span class="lineno"> 3628</span>                <span class="keyword">using </span>member_types = <span class="keyword">typename</span> type_descriptor&lt;typename WritableMember::declaring_type&gt;::declared_member_types;</div>
<div class="line"><span class="lineno"> 3629</span>                <span class="keyword">constexpr</span> <span class="keyword">auto</span> member_index = detail::get_member_index(member);</div>
<div class="line"><span class="lineno"> 3630</span> </div>
<div class="line"><span class="lineno"> 3631</span>                <span class="comment">// Optimisation for the getter defined after setter pattern.</span></div>
<div class="line"><span class="lineno"> 3632</span>                <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (member_index != member_types::size - 1) {</div>
<div class="line"><span class="lineno"> 3633</span>                    <span class="keyword">using </span>likely_match = trait::get_t&lt;member_index + 1, member_types&gt;;</div>
<div class="line"><span class="lineno"> 3634</span>                    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (match(likely_match{})) {</div>
<div class="line"><span class="lineno"> 3635</span>                        <span class="keywordflow">return</span> likely_match{};</div>
<div class="line"><span class="lineno"> 3636</span>                    }</div>
<div class="line"><span class="lineno"> 3637</span>                }</div>
<div class="line"><span class="lineno"> 3638</span> </div>
<div class="line"><span class="lineno"> 3639</span>                <span class="comment">// Optimisation for the getter defined after setter pattern.</span></div>
<div class="line"><span class="lineno"> 3640</span>                <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (member_index != 0) {</div>
<div class="line"><span class="lineno"> 3641</span>                    <span class="keyword">using </span>likely_match = trait::get_t&lt;member_index - 1, member_types&gt;;</div>
<div class="line"><span class="lineno"> 3642</span>                    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (match(likely_match{})) {</div>
<div class="line"><span class="lineno"> 3643</span>                        <span class="keywordflow">return</span> likely_match{};</div>
<div class="line"><span class="lineno"> 3644</span>                    }</div>
<div class="line"><span class="lineno"> 3645</span>                    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3646</span>                        <span class="keywordflow">return</span> detail::get_reader_search(member);</div>
<div class="line"><span class="lineno"> 3647</span>                    }</div>
<div class="line"><span class="lineno"> 3648</span>                }</div>
<div class="line"><span class="lineno"> 3649</span>                <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3650</span>                    <span class="keywordflow">return</span> detail::get_reader_search(member);</div>
<div class="line"><span class="lineno"> 3651</span>                }</div>
<div class="line"><span class="lineno"> 3652</span>            }</div>
<div class="line"><span class="lineno"> 3653</span>            <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3654</span>                <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#a3d943ef351c700532badfa3c5d4ba953">has_reader</a>(member), <span class="stringliteral">&quot;The property is not readable (could not find a getter method)!&quot;</span>);</div>
<div class="line"><span class="lineno"> 3655</span>            }</div>
<div class="line"><span class="lineno"> 3656</span>        }</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a288a833843be97b2d80b51b1de886f99"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a288a833843be97b2d80b51b1de886f99">refl::descriptor::is_property</a></div><div class="ttdeci">constexpr bool is_property(MemberDescriptor d) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03085">refl.hpp:3085</a></div></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a3d943ef351c700532badfa3c5d4ba953"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a3d943ef351c700532badfa3c5d4ba953">refl::descriptor::has_reader</a></div><div class="ttdeci">constexpr bool has_reader(WritableMember member)</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03524">refl.hpp:3524</a></div></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_aa68bedab33d684ee5ee4ead24c5586ab"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab">refl::descriptor::is_readable</a></div><div class="ttdeci">constexpr bool is_readable(MemberDescriptor) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03128">refl.hpp:3128</a></div></div>
</div><!-- fragment -->
<p class="reference">参照先 <a class="el" href="refl_8hpp_source.html#l03466">get_display_name_const()</a>, <a class="el" href="refl_8hpp_source.html#l03352">refl::descriptor::detail::get_member_index()</a>, <a class="el" href="refl_8hpp_source.html#l03399">refl::descriptor::detail::get_reader_search()</a>, <a class="el" href="refl_8hpp_source.html#l03524">has_reader()</a>, <a class="el" href="refl_8hpp_source.html#l03085">is_property()</a>, <a class="el" href="refl_8hpp_source.html#l03128">is_readable()</a>.</p>
<div class="dynheader">
呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a3690f579517cc28e9d2eacb3d095fdbb_cgraph.svg" width="1246" height="331"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5621e8b981bfb910f027fb720320f977" name="a5621e8b981bfb910f027fb720320f977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5621e8b981bfb910f027fb720320f977">&#9670;&#160;</a></span>get_simple_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_simple_name </td>
          <td>(</td>
          <td class="paramtype">TypeDescriptor&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the unqualified name of the type, discarding the namespace and typenames (if a template type).</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a5621e8b981bfb910f027fb720320f977">get_simple_name</a>(<a class="code hl_function" href="namespacerefl.html#a86dba5a377d375a2d28b60d16b185e2c">reflect</a>&lt;std::vector&lt;float&gt;&gt;()) -&gt; <span class="stringliteral">&quot;vector&quot;</span></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a5621e8b981bfb910f027fb720320f977"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a5621e8b981bfb910f027fb720320f977">refl::descriptor::get_simple_name</a></div><div class="ttdeci">constexpr auto get_simple_name(TypeDescriptor t)</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03230">refl.hpp:3230</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03230">3230</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3231</span>        {</div>
<div class="line"><span class="lineno"> 3232</span>            <span class="keyword">static_assert</span>(trait::is_type_v&lt;TypeDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 3233</span>            <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> template_start = t.name.find(<span class="charliteral">&#39;&lt;&#39;</span>);</div>
<div class="line"><span class="lineno"> 3234</span>            <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> scope_last = t.name.rfind(<span class="charliteral">&#39;:&#39;</span>, template_start);</div>
<div class="line"><span class="lineno"> 3235</span>            <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (scope_last == <a class="code hl_struct" href="structrefl_1_1util_1_1const__string.html">const_string&lt;0&gt;::npos</a>) {</div>
<div class="line"><span class="lineno"> 3236</span>                <span class="keywordflow">return</span> t.name;</div>
<div class="line"><span class="lineno"> 3237</span>            }</div>
<div class="line"><span class="lineno"> 3238</span>            <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3239</span>                <span class="keywordflow">return</span> t.name.template substr&lt;scope_last + 1, template_start - scope_last - 1&gt;();</div>
<div class="line"><span class="lineno"> 3240</span>            }</div>
<div class="line"><span class="lineno"> 3241</span>        }</div>
<div class="ttc" id="astructrefl_1_1util_1_1const__string_html"><div class="ttname"><a href="structrefl_1_1util_1_1const__string.html">refl::util::const_string</a></div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l00104">refl.hpp:105</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4cc337624b45bd2d5f9b27d6811fafd" name="ad4cc337624b45bd2d5f9b27d6811fafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cc337624b45bd2d5f9b27d6811fafd">&#9670;&#160;</a></span>get_writer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadableMember &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::get_writer </td>
          <td>(</td>
          <td class="paramtype">ReadableMember&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a member that has the same display name as the one provied and is writable. For getter methods with a property attribute, the return value will the reflected setter method with a property with the same display name (property name normalization applies automatically). For fields, returns the same descriptor if writable. </p>

<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03569">3569</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3570</span>        {</div>
<div class="line"><span class="lineno"> 3571</span>            <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#a925e8cb99d6199fe03edeb5109958f8d">is_writable</a>(member) || <a class="code hl_function" href="namespacerefl_1_1descriptor.html#a288a833843be97b2d80b51b1de886f99">is_property</a>(member));</div>
<div class="line"><span class="lineno"> 3572</span>            <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_function" href="namespacerefl_1_1descriptor.html#a925e8cb99d6199fe03edeb5109958f8d">is_writable</a>(member)) {</div>
<div class="line"><span class="lineno"> 3573</span>                <span class="keywordflow">return</span> member;</div>
<div class="line"><span class="lineno"> 3574</span>            }</div>
<div class="line"><span class="lineno"> 3575</span>            <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (has_writer(member)) {</div>
<div class="line"><span class="lineno"> 3576</span>                <span class="keyword">constexpr</span> <span class="keyword">auto</span> match = [](<span class="keyword">auto</span> m) {</div>
<div class="line"><span class="lineno"> 3577</span>                    <span class="keywordflow">return</span> is_property(m) &amp;&amp; is_writable(m) &amp;&amp; get_display_name_const(m) == get_display_name_const(ReadableMember{});</div>
<div class="line"><span class="lineno"> 3578</span>                };</div>
<div class="line"><span class="lineno"> 3579</span> </div>
<div class="line"><span class="lineno"> 3580</span>                <span class="keyword">using </span>member_types = <span class="keyword">typename</span> type_descriptor&lt;typename ReadableMember::declaring_type&gt;::declared_member_types;</div>
<div class="line"><span class="lineno"> 3581</span>                <span class="keyword">constexpr</span> <span class="keyword">auto</span> member_index = detail::get_member_index(member);</div>
<div class="line"><span class="lineno"> 3582</span> </div>
<div class="line"><span class="lineno"> 3583</span>                <span class="comment">// Optimisation for the getter defined after setter pattern.</span></div>
<div class="line"><span class="lineno"> 3584</span>                <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (member_index != 0) {</div>
<div class="line"><span class="lineno"> 3585</span>                    <span class="keyword">using </span>likely_match = trait::get_t&lt;member_index - 1, member_types&gt;;</div>
<div class="line"><span class="lineno"> 3586</span>                    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (match(likely_match{})) {</div>
<div class="line"><span class="lineno"> 3587</span>                        <span class="keywordflow">return</span> likely_match{};</div>
<div class="line"><span class="lineno"> 3588</span>                    }</div>
<div class="line"><span class="lineno"> 3589</span>                }</div>
<div class="line"><span class="lineno"> 3590</span> </div>
<div class="line"><span class="lineno"> 3591</span>                <span class="comment">// Optimisation for the getter defined after setter pattern.</span></div>
<div class="line"><span class="lineno"> 3592</span>                <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (member_index != member_types::size - 1) {</div>
<div class="line"><span class="lineno"> 3593</span>                    <span class="keyword">using </span>likely_match = trait::get_t&lt;member_index + 1, member_types&gt;;</div>
<div class="line"><span class="lineno"> 3594</span>                    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (match(likely_match{})) {</div>
<div class="line"><span class="lineno"> 3595</span>                        <span class="keywordflow">return</span> likely_match{};</div>
<div class="line"><span class="lineno"> 3596</span>                    }</div>
<div class="line"><span class="lineno"> 3597</span>                    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3598</span>                        <span class="keywordflow">return</span> detail::get_writer_search(member);</div>
<div class="line"><span class="lineno"> 3599</span>                    }</div>
<div class="line"><span class="lineno"> 3600</span>                }</div>
<div class="line"><span class="lineno"> 3601</span>                <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3602</span>                    <span class="keywordflow">return</span> detail::get_writer_search(member);</div>
<div class="line"><span class="lineno"> 3603</span>                }</div>
<div class="line"><span class="lineno"> 3604</span>            }</div>
<div class="line"><span class="lineno"> 3605</span>            <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3606</span>                <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#a3677023906e7fb31d6267d4afdaeffde">has_writer</a>(member), <span class="stringliteral">&quot;The property is not writable (could not find a setter method)!&quot;</span>);</div>
<div class="line"><span class="lineno"> 3607</span>            }</div>
<div class="line"><span class="lineno"> 3608</span>        }</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a3677023906e7fb31d6267d4afdaeffde"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a3677023906e7fb31d6267d4afdaeffde">refl::descriptor::has_writer</a></div><div class="ttdeci">constexpr bool has_writer(ReadableMember member)</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03479">refl.hpp:3479</a></div></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a925e8cb99d6199fe03edeb5109958f8d"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a925e8cb99d6199fe03edeb5109958f8d">refl::descriptor::is_writable</a></div><div class="ttdeci">constexpr bool is_writable(MemberDescriptor) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03156">refl.hpp:3156</a></div></div>
</div><!-- fragment -->
<p class="reference">参照先 <a class="el" href="refl_8hpp_source.html#l03466">get_display_name_const()</a>, <a class="el" href="refl_8hpp_source.html#l03352">refl::descriptor::detail::get_member_index()</a>, <a class="el" href="refl_8hpp_source.html#l03413">refl::descriptor::detail::get_writer_search()</a>, <a class="el" href="refl_8hpp_source.html#l03479">has_writer()</a>, <a class="el" href="refl_8hpp_source.html#l03085">is_property()</a>, <a class="el" href="refl_8hpp_source.html#l03156">is_writable()</a>.</p>
<div class="dynheader">
呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_ad4cc337624b45bd2d5f9b27d6811fafd_cgraph.svg" width="1246" height="366"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a024d98e2fa7e18a1d7ece243549cde68" name="a024d98e2fa7e18a1d7ece243549cde68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024d98e2fa7e18a1d7ece243549cde68">&#9670;&#160;</a></span>has_attribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classA.html">A</a> , typename Descriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool refl::descriptor::has_attribute </td>
          <td>(</td>
          <td class="paramtype">Descriptor&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether T has an attribute of type <a class="el" href="classA.html">A</a>.</p>
<div class="fragment"><div class="line">REFL_AUTO(type(User), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">get_name</a>, property()), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(set_name, property()))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a024d98e2fa7e18a1d7ece243549cde68">has_attribute</a>&lt;attr::property&gt;(get_t&lt;0, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list</a>&lt;User&gt;&gt;{}) -&gt; true</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a024d98e2fa7e18a1d7ece243549cde68"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a024d98e2fa7e18a1d7ece243549cde68">refl::descriptor::has_attribute</a></div><div class="ttdeci">constexpr bool has_attribute(Descriptor) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03022">refl.hpp:3022</a></div></div>
</div><!-- fragment --><p>Checks whether T has an attribute of that is a template instance of <a class="el" href="classA.html">A</a>.</p>
<div class="fragment"><div class="line">REFL_AUTO(type(Random, debug{ [](<span class="keyword">auto</span> os, <span class="keyword">auto</span>){ os &lt;&lt; <span class="stringliteral">&quot;[Random]&quot;</span>; } }))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a024d98e2fa7e18a1d7ece243549cde68">has_attribute</a>&lt;attr::debug&gt;(<a class="code hl_function" href="namespacerefl.html#a86dba5a377d375a2d28b60d16b185e2c">reflect</a>&lt;Random&gt;()) -&gt; true</div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03022">3022</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3023</span>        {</div>
<div class="line"><span class="lineno"> 3024</span>            <span class="keyword">static_assert</span>(trait::is_descriptor_v&lt;Descriptor&gt;);</div>
<div class="line"><span class="lineno"> 3025</span>            <span class="keywordflow">return</span> trait::contains_base_v&lt;A, typename Descriptor::attribute_types&gt;;</div>
<div class="line"><span class="lineno"> 3026</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac00126ab409dbc1a5445d37832876fe2" name="ac00126ab409dbc1a5445d37832876fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00126ab409dbc1a5445d37832876fe2">&#9670;&#160;</a></span>has_bases()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::has_bases </td>
          <td>(</td>
          <td class="paramtype">TypeDescriptor&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if a type has a bases attribute.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">非推奨:</a></b></dt><dd>Use has_base_types in combination with reflect_types instead. </dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacerefl_1_1attr.html#a4a28906fa1330c1e8df39e6ccd4d9c19">refl::attr::bases</a> </dd>
<dd>
<a class="el" href="namespacerefl_1_1descriptor.html#a725c882cfae058b70d50517fe134a938">refl::descriptor::get_bases</a></dd></dl>
<div class="fragment"><div class="line">REFL_AUTO(type(Dog, bases&lt;Animal&gt;))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#ac00126ab409dbc1a5445d37832876fe2">has_bases</a>(reflect&lt;Dog&gt;()) -&gt; <span class="keyword">true</span></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03192">3192</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3193</span>        {</div>
<div class="line"><span class="lineno"> 3194</span>            <span class="keyword">static_assert</span>(trait::is_type_v&lt;TypeDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 3195</span>            <span class="keywordflow">return</span> has_attribute&lt;attr::base_types&gt;(t);</div>
<div class="line"><span class="lineno"> 3196</span>        }</div>
</div><!-- fragment -->
<p class="reference">参照元 <a class="el" href="refl_8hpp_source.html#l03212">get_bases()</a>.</p>
<div class="dynheader">
被呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_ac00126ab409dbc1a5445d37832876fe2_icgraph.svg" width="351" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3d943ef351c700532badfa3c5d4ba953" name="a3d943ef351c700532badfa3c5d4ba953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d943ef351c700532badfa3c5d4ba953">&#9670;&#160;</a></span>has_reader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WritableMember &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool refl::descriptor::has_reader </td>
          <td>(</td>
          <td class="paramtype">WritableMember&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if there exists a member that has the same display name as the one provied and is readable. For setter methods with a property attribute, the return value will be true if there exists a reflected getter method with a property with the same display name (property name normalization applies automatically). For fields, returns true. </p>

<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03524">3524</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3525</span>        {</div>
<div class="line"><span class="lineno"> 3526</span>            <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab">is_readable</a>(member) || <a class="code hl_function" href="namespacerefl_1_1descriptor.html#a288a833843be97b2d80b51b1de886f99">is_property</a>(member));</div>
<div class="line"><span class="lineno"> 3527</span>            <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_function" href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab">is_readable</a>(member)) {</div>
<div class="line"><span class="lineno"> 3528</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3529</span>            }</div>
<div class="line"><span class="lineno"> 3530</span>            <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3531</span>                [[maybe_unused]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> match = [](<span class="keyword">auto</span> m) {</div>
<div class="line"><span class="lineno"> 3532</span>                    <span class="keywordflow">return</span> is_property(m) &amp;&amp; is_readable(m) &amp;&amp; get_display_name_const(m) == get_display_name_const(WritableMember{});</div>
<div class="line"><span class="lineno"> 3533</span>                };</div>
<div class="line"><span class="lineno"> 3534</span> </div>
<div class="line"><span class="lineno"> 3535</span>                <span class="keyword">using </span>member_types = <span class="keyword">typename</span> type_descriptor&lt;typename WritableMember::declaring_type&gt;::declared_member_types;</div>
<div class="line"><span class="lineno"> 3536</span>                <span class="keyword">constexpr</span> <span class="keyword">auto</span> member_index = detail::get_member_index(member);</div>
<div class="line"><span class="lineno"> 3537</span> </div>
<div class="line"><span class="lineno"> 3538</span>                <span class="comment">// Optimisation for the getter defined after setter pattern.</span></div>
<div class="line"><span class="lineno"> 3539</span>                <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (member_index != member_types::size - 1) {</div>
<div class="line"><span class="lineno"> 3540</span>                    <span class="keyword">using </span>likely_match = trait::get_t&lt;member_index + 1, member_types&gt;;</div>
<div class="line"><span class="lineno"> 3541</span>                    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (match(likely_match{})) {</div>
<div class="line"><span class="lineno"> 3542</span>                        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3543</span>                    }</div>
<div class="line"><span class="lineno"> 3544</span>                }</div>
<div class="line"><span class="lineno"> 3545</span> </div>
<div class="line"><span class="lineno"> 3546</span>                <span class="comment">// Optimisation for the getter defined after setter pattern.</span></div>
<div class="line"><span class="lineno"> 3547</span>                <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (member_index != 0) {</div>
<div class="line"><span class="lineno"> 3548</span>                    <span class="keyword">using </span>likely_match = trait::get_t&lt;member_index - 1, member_types&gt;;</div>
<div class="line"><span class="lineno"> 3549</span>                    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (match(likely_match{})) {</div>
<div class="line"><span class="lineno"> 3550</span>                        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3551</span>                    }</div>
<div class="line"><span class="lineno"> 3552</span>                    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3553</span>                        <span class="keywordflow">return</span> detail::has_reader_search(member);</div>
<div class="line"><span class="lineno"> 3554</span>                    }</div>
<div class="line"><span class="lineno"> 3555</span>                }</div>
<div class="line"><span class="lineno"> 3556</span>                <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3557</span>                    <span class="keywordflow">return</span> detail::has_reader_search(member);</div>
<div class="line"><span class="lineno"> 3558</span>                }</div>
<div class="line"><span class="lineno"> 3559</span>            }</div>
<div class="line"><span class="lineno"> 3560</span>        }</div>
</div><!-- fragment -->
<p class="reference">参照先 <a class="el" href="refl_8hpp_source.html#l03466">get_display_name_const()</a>, <a class="el" href="refl_8hpp_source.html#l03352">refl::descriptor::detail::get_member_index()</a>, <a class="el" href="refl_8hpp_source.html#l03371">refl::descriptor::detail::has_reader_search()</a>, <a class="el" href="refl_8hpp_source.html#l03085">is_property()</a>, <a class="el" href="refl_8hpp_source.html#l03128">is_readable()</a>.</p>

<p class="reference">参照元 <a class="el" href="refl_8hpp_source.html#l03617">get_reader()</a>.</p>
<div class="dynheader">
呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a3d943ef351c700532badfa3c5d4ba953_cgraph.svg" width="1038" height="362"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
被呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a3d943ef351c700532badfa3c5d4ba953_icgraph.svg" width="351" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3677023906e7fb31d6267d4afdaeffde" name="a3677023906e7fb31d6267d4afdaeffde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3677023906e7fb31d6267d4afdaeffde">&#9670;&#160;</a></span>has_writer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadableMember &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool refl::descriptor::has_writer </td>
          <td>(</td>
          <td class="paramtype">ReadableMember&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if there exists a member that has the same display name as the one provied and is writable. For getter methods with a property attribute, the return value will be true if there exists a reflected setter method with a property with the same display name (property name normalization applies automatically). For fields, returns true only if the field is writable. </p>

<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03479">3479</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3480</span>        {</div>
<div class="line"><span class="lineno"> 3481</span>            <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#a925e8cb99d6199fe03edeb5109958f8d">is_writable</a>(member) || <a class="code hl_function" href="namespacerefl_1_1descriptor.html#a288a833843be97b2d80b51b1de886f99">is_property</a>(member));</div>
<div class="line"><span class="lineno"> 3482</span>            <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_function" href="namespacerefl_1_1descriptor.html#a925e8cb99d6199fe03edeb5109958f8d">is_writable</a>(member)) {</div>
<div class="line"><span class="lineno"> 3483</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3484</span>            }</div>
<div class="line"><span class="lineno"> 3485</span>            <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3486</span>                [[maybe_unused]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> match = [](<span class="keyword">auto</span> m) {</div>
<div class="line"><span class="lineno"> 3487</span>                    <span class="keywordflow">return</span> is_property(m) &amp;&amp; is_writable(m) &amp;&amp; get_display_name_const(m) == get_display_name_const(ReadableMember{});</div>
<div class="line"><span class="lineno"> 3488</span>                };</div>
<div class="line"><span class="lineno"> 3489</span> </div>
<div class="line"><span class="lineno"> 3490</span>                <span class="keyword">using </span>member_types = <span class="keyword">typename</span> type_descriptor&lt;typename ReadableMember::declaring_type&gt;::declared_member_types;</div>
<div class="line"><span class="lineno"> 3491</span>                <span class="keyword">constexpr</span> <span class="keyword">auto</span> member_index = detail::get_member_index(member);</div>
<div class="line"><span class="lineno"> 3492</span> </div>
<div class="line"><span class="lineno"> 3493</span>                <span class="comment">// Optimisation for the getter defined after setter pattern.</span></div>
<div class="line"><span class="lineno"> 3494</span>                <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (member_index != 0) {</div>
<div class="line"><span class="lineno"> 3495</span>                    <span class="keyword">using </span>likely_match = trait::get_t&lt;member_index - 1, member_types&gt;;</div>
<div class="line"><span class="lineno"> 3496</span>                    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (match(likely_match{})) {</div>
<div class="line"><span class="lineno"> 3497</span>                        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3498</span>                    }</div>
<div class="line"><span class="lineno"> 3499</span>                }</div>
<div class="line"><span class="lineno"> 3500</span> </div>
<div class="line"><span class="lineno"> 3501</span>                <span class="comment">// Optimisation for the getter defined after setter pattern.</span></div>
<div class="line"><span class="lineno"> 3502</span>                <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (member_index != member_types::size - 1) {</div>
<div class="line"><span class="lineno"> 3503</span>                    <span class="keyword">using </span>likely_match = trait::get_t&lt;member_index + 1, member_types&gt;;</div>
<div class="line"><span class="lineno"> 3504</span>                    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (match(likely_match{})) {</div>
<div class="line"><span class="lineno"> 3505</span>                        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3506</span>                    }</div>
<div class="line"><span class="lineno"> 3507</span>                    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3508</span>                        <span class="keywordflow">return</span> detail::has_writer_search(member);</div>
<div class="line"><span class="lineno"> 3509</span>                    }</div>
<div class="line"><span class="lineno"> 3510</span>                }</div>
<div class="line"><span class="lineno"> 3511</span>                <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3512</span>                    <span class="keywordflow">return</span> detail::has_writer_search(member);</div>
<div class="line"><span class="lineno"> 3513</span>                }</div>
<div class="line"><span class="lineno"> 3514</span>            }</div>
<div class="line"><span class="lineno"> 3515</span>        }</div>
</div><!-- fragment -->
<p class="reference">参照先 <a class="el" href="refl_8hpp_source.html#l03466">get_display_name_const()</a>, <a class="el" href="refl_8hpp_source.html#l03352">refl::descriptor::detail::get_member_index()</a>, <a class="el" href="refl_8hpp_source.html#l03385">refl::descriptor::detail::has_writer_search()</a>, <a class="el" href="refl_8hpp_source.html#l03085">is_property()</a>, <a class="el" href="refl_8hpp_source.html#l03156">is_writable()</a>.</p>

<p class="reference">参照元 <a class="el" href="refl_8hpp_source.html#l03569">get_writer()</a>.</p>
<div class="dynheader">
呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a3677023906e7fb31d6267d4afdaeffde_cgraph.svg" width="1038" height="362"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
被呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a3677023906e7fb31d6267d4afdaeffde_icgraph.svg" width="351" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab17264f6fe5ef2e6f10a67304cb40e83" name="ab17264f6fe5ef2e6f10a67304cb40e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17264f6fe5ef2e6f10a67304cb40e83">&#9670;&#160;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemberDescriptor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::invoke </td>
          <td>(</td>
          <td class="paramtype">MemberDescriptor&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(d(std::forward&lt;Args&gt;(args)...))
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invokes the member with the specified arguments.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">int</span> bar = 1;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> baz = 5;</div>
<div class="line">  <span class="keywordtype">void</span> foobar(<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * 2; }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> foobaz(<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * 3; }</div>
<div class="line">};</div>
<div class="line">REFL_AUTO(type(Foo), field(bar), field(baz), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(foobar), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(foobaz))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#ab17264f6fe5ef2e6f10a67304cb40e83">invoke</a>(get_t&lt;0, member_list&lt;Foo&gt;(), Foo()) -&gt; 1 (Foo().bar)</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#ab17264f6fe5ef2e6f10a67304cb40e83">invoke</a>(get_t&lt;1, member_list&lt;Foo&gt;&gt;()) -&gt; 5 (Foo::baz)</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#ab17264f6fe5ef2e6f10a67304cb40e83">invoke</a>(get_t&lt;2, member_list&lt;Foo&gt;(), Foo(), 10) -&gt; 20 (Foo().foobar())</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#ab17264f6fe5ef2e6f10a67304cb40e83">invoke</a>(get_t&lt;3, member_list&lt;Foo&gt;&gt;()) -&gt; 30 (Foo::foobaz())</div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_ab17264f6fe5ef2e6f10a67304cb40e83"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#ab17264f6fe5ef2e6f10a67304cb40e83">refl::descriptor::invoke</a></div><div class="ttdeci">constexpr auto invoke(MemberDescriptor d, Args &amp;&amp;... args) noexcept -&gt; decltype(d(std::forward&lt; Args &gt;(args)...))</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02844">refl.hpp:2844</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02844">2844</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2845</span>        {</div>
<div class="line"><span class="lineno"> 2846</span>            <span class="keywordflow">return</span> d(std::forward&lt;Args&gt;(args)...);</div>
<div class="line"><span class="lineno"> 2847</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6127ab327b1e8f31062e9d0e2440a757" name="a6127ab327b1e8f31062e9d0e2440a757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6127ab327b1e8f31062e9d0e2440a757">&#9670;&#160;</a></span>is_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::is_const </td>
          <td>(</td>
          <td class="paramtype">FieldDescriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the value type of the field is const-qualified.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">int</span> bar;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> baz;</div>
<div class="line">};</div>
<div class="line">REFL_AUTO(type(Foo), field(bar), field(baz))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a6127ab327b1e8f31062e9d0e2440a757">is_const</a>(get_t&lt;0, member_list&lt;Foo&gt;&gt;()) -&gt; <span class="keyword">false</span></div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a6127ab327b1e8f31062e9d0e2440a757">is_const</a>(get_t&lt;1, member_list&lt;Foo&gt;&gt;()) -&gt; <span class="keyword">true</span></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a6127ab327b1e8f31062e9d0e2440a757"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a6127ab327b1e8f31062e9d0e2440a757">refl::descriptor::is_const</a></div><div class="ttdeci">constexpr auto is_const(FieldDescriptor d) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02883">refl.hpp:2883</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02883">2883</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2884</span>        {</div>
<div class="line"><span class="lineno"> 2885</span>            <span class="keyword">static_assert</span>(trait::is_field_v&lt;FieldDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 2886</span>            <span class="keywordflow">return</span> d.is_const;</div>
<div class="line"><span class="lineno"> 2887</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1454a5c8702f245ceafaa9731026f7fe" name="a1454a5c8702f245ceafaa9731026f7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1454a5c8702f245ceafaa9731026f7fe">&#9670;&#160;</a></span>is_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Descriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool refl::descriptor::is_field </td>
          <td>(</td>
          <td class="paramtype">Descriptor&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether T is a field descriptor.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="classrefl_1_1descriptor_1_1field__descriptor.html" title="Represents a reflected field.">refl::descriptor::field_descriptor</a></dd></dl>
<div class="fragment"><div class="line">REFL_AUTO(type(Foo), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(bar), field(baz))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a76608e349f1f11d8e7eb5ccb759806a6">is_function</a>(get_t&lt;0, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list&lt;Foo&gt;</a>&gt;()) -&gt; <span class="keyword">false</span></div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a76608e349f1f11d8e7eb5ccb759806a6">is_function</a>(get_t&lt;1, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list&lt;Foo&gt;</a>&gt;()) -&gt; <span class="keyword">true</span></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a76608e349f1f11d8e7eb5ccb759806a6"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a76608e349f1f11d8e7eb5ccb759806a6">refl::descriptor::is_function</a></div><div class="ttdeci">constexpr bool is_function(Descriptor) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02990">refl.hpp:2990</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02972">2972</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2973</span>        {</div>
<div class="line"><span class="lineno"> 2974</span>            <span class="keyword">static_assert</span>(trait::is_descriptor_v&lt;Descriptor&gt;);</div>
<div class="line"><span class="lineno"> 2975</span>            <span class="keywordflow">return</span> trait::is_field_v&lt;Descriptor&gt;;</div>
<div class="line"><span class="lineno"> 2976</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a76608e349f1f11d8e7eb5ccb759806a6" name="a76608e349f1f11d8e7eb5ccb759806a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76608e349f1f11d8e7eb5ccb759806a6">&#9670;&#160;</a></span>is_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Descriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool refl::descriptor::is_function </td>
          <td>(</td>
          <td class="paramtype">Descriptor&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether T is a function descriptor.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="classrefl_1_1descriptor_1_1function__descriptor.html" title="Represents a reflected function.">refl::descriptor::function_descriptor</a></dd></dl>
<div class="fragment"><div class="line">REFL_AUTO(type(Foo), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(bar), field(baz))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a76608e349f1f11d8e7eb5ccb759806a6">is_function</a>(get_t&lt;0, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list&lt;Foo&gt;</a>&gt;()) -&gt; <span class="keyword">true</span></div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a76608e349f1f11d8e7eb5ccb759806a6">is_function</a>(get_t&lt;1, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list&lt;Foo&gt;</a>&gt;()) -&gt; <span class="keyword">false</span></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02990">2990</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2991</span>        {</div>
<div class="line"><span class="lineno"> 2992</span>            <span class="keyword">static_assert</span>(trait::is_descriptor_v&lt;Descriptor&gt;);</div>
<div class="line"><span class="lineno"> 2993</span>            <span class="keywordflow">return</span> trait::is_function_v&lt;Descriptor&gt;;</div>
<div class="line"><span class="lineno"> 2994</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a288a833843be97b2d80b51b1de886f99" name="a288a833843be97b2d80b51b1de886f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288a833843be97b2d80b51b1de886f99">&#9670;&#160;</a></span>is_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemberDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool refl::descriptor::is_property </td>
          <td>(</td>
          <td class="paramtype">MemberDescriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether T is a member descriptor marked with the property attribute.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="structrefl_1_1attr_1_1property.html">refl::attr::property</a> </dd>
<dd>
<a class="el" href="namespacerefl_1_1descriptor.html#aadb1bb89c2469071ced6551ca3b9b8fd">refl::descriptor::get_property</a></dd></dl>
<div class="fragment"><div class="line">REFL_AUTO(type(User), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">get_name</a>, property(<span class="stringliteral">&quot;user_name&quot;</span>)), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(set_name, property()))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a288a833843be97b2d80b51b1de886f99">is_property</a>(get_t&lt;0, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list</a>&lt;User&gt;&gt;{}) -&gt; true</div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03085">3085</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3086</span>        {</div>
<div class="line"><span class="lineno"> 3087</span>            <span class="keyword">static_assert</span>(trait::is_member_v&lt;MemberDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 3088</span>            <span class="keywordflow">return</span> has_attribute&lt;attr::property&gt;(d);</div>
<div class="line"><span class="lineno"> 3089</span>        }</div>
</div><!-- fragment -->
<p class="reference">参照元 <a class="el" href="refl_8hpp_source.html#l03617">get_reader()</a>, <a class="el" href="refl_8hpp_source.html#l03569">get_writer()</a>, <a class="el" href="refl_8hpp_source.html#l03524">has_reader()</a>, <a class="el" href="refl_8hpp_source.html#l03479">has_writer()</a>.</p>
<div class="dynheader">
被呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a288a833843be97b2d80b51b1de886f99_icgraph.svg" width="534" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa68bedab33d684ee5ee4ead24c5586ab" name="aa68bedab33d684ee5ee4ead24c5586ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68bedab33d684ee5ee4ead24c5586ab">&#9670;&#160;</a></span>is_readable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemberDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool refl::descriptor::is_readable </td>
          <td>(</td>
          <td class="paramtype">MemberDescriptor&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if T is a 0-arg const-qualified member function with a property attribute or a field.</p>
<div class="fragment"><div class="line">REFL_AUTO(type(User), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">get_name</a>, property()), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(set_name, property()))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab">is_readable</a>(get_t&lt;0, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list</a>&lt;User&gt;&gt;{}) -&gt; <span class="keyword">true</span></div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab">is_readable</a>(get_t&lt;1, member_list&lt;User&gt;&gt;{}) -&gt; false</div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03128">3128</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3129</span>        {</div>
<div class="line"><span class="lineno"> 3130</span>            <span class="keyword">static_assert</span>(trait::is_member_v&lt;MemberDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 3131</span>            <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (trait::is_property_v&lt;MemberDescriptor&gt;) {</div>
<div class="line"><span class="lineno"> 3132</span>                <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_invocable_v&lt;MemberDescriptor, const typename MemberDescriptor::declaring_type&amp;&gt;) {</div>
<div class="line"><span class="lineno"> 3133</span>                    <span class="keyword">using </span>return_type = <span class="keyword">typename</span> MemberDescriptor::template return_type&lt;const typename MemberDescriptor::declaring_type&amp;&gt;;</div>
<div class="line"><span class="lineno"> 3134</span>                    <span class="keywordflow">return</span> !std::is_void_v&lt;return_type&gt;;</div>
<div class="line"><span class="lineno"> 3135</span>                }</div>
<div class="line"><span class="lineno"> 3136</span>                <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3137</span>                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 3138</span>                }</div>
<div class="line"><span class="lineno"> 3139</span>            }</div>
<div class="line"><span class="lineno"> 3140</span>            <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3141</span>                <span class="keywordflow">return</span> trait::is_field_v&lt;MemberDescriptor&gt;;</div>
<div class="line"><span class="lineno"> 3142</span>            }</div>
<div class="line"><span class="lineno"> 3143</span>        }</div>
</div><!-- fragment -->
<p class="reference">参照元 <a class="el" href="refl_8hpp_source.html#l03617">get_reader()</a>, <a class="el" href="refl_8hpp_source.html#l03524">has_reader()</a>, <a class="el" href="refl_8hpp_source.html#l03313">refl::descriptor::detail::normalize_accessor_name()</a>.</p>
<div class="dynheader">
被呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_aa68bedab33d684ee5ee4ead24c5586ab_icgraph.svg" width="1235" height="328"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8d2afa6e939c641de9a9f184388341da" name="a8d2afa6e939c641de9a9f184388341da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2afa6e939c641de9a9f184388341da">&#9670;&#160;</a></span>is_resolved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::is_resolved </td>
          <td>(</td>
          <td class="paramtype">FunctionDescriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the function pointer was automatically resolved.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">void</span> bar();</div>
<div class="line">  <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>);</div>
<div class="line">  <span class="keywordtype">void</span> baz();</div>
<div class="line">};</div>
<div class="line">REFL_AUTO(type(Foo), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(bar), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(baz))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a8d2afa6e939c641de9a9f184388341da">is_resolved</a>(get_t&lt;0, member_list&lt;Foo&gt;&gt;()) -&gt; <span class="keyword">false</span></div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a8d2afa6e939c641de9a9f184388341da">is_resolved</a>(get_t&lt;1, member_list&lt;Foo&gt;&gt;()) -&gt; <span class="keyword">true</span></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a8d2afa6e939c641de9a9f184388341da"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a8d2afa6e939c641de9a9f184388341da">refl::descriptor::is_resolved</a></div><div class="ttdeci">constexpr auto is_resolved(FunctionDescriptor d) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02911">refl.hpp:2911</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02911">2911</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2912</span>        {</div>
<div class="line"><span class="lineno"> 2913</span>            <span class="keyword">static_assert</span>(trait::is_function_v&lt;FunctionDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 2914</span>            <span class="keywordflow">return</span> d.is_resolved;</div>
<div class="line"><span class="lineno"> 2915</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a19a133a31fb133920609bba17fad68b2" name="a19a133a31fb133920609bba17fad68b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a133a31fb133920609bba17fad68b2">&#9670;&#160;</a></span>is_static()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::is_static </td>
          <td>(</td>
          <td class="paramtype">FieldDescriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the field is declared as static.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">int</span> bar;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> baz;</div>
<div class="line">};</div>
<div class="line">REFL_AUTO(type(Foo), field(bar), field(baz))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a19a133a31fb133920609bba17fad68b2">is_static</a>(get_t&lt;0, member_list&lt;Foo&gt;&gt;()) -&gt; <span class="keyword">false</span></div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a19a133a31fb133920609bba17fad68b2">is_static</a>(get_t&lt;1, member_list&lt;Foo&gt;&gt;()) -&gt; <span class="keyword">true</span></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_a19a133a31fb133920609bba17fad68b2"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#a19a133a31fb133920609bba17fad68b2">refl::descriptor::is_static</a></div><div class="ttdeci">constexpr auto is_static(FieldDescriptor d) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l02863">refl.hpp:2863</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02863">2863</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2864</span>        {</div>
<div class="line"><span class="lineno"> 2865</span>            <span class="keyword">static_assert</span>(trait::is_field_v&lt;FieldDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 2866</span>            <span class="keywordflow">return</span> d.is_static;</div>
<div class="line"><span class="lineno"> 2867</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abe2665e32dba32044036fa66303c12aa" name="abe2665e32dba32044036fa66303c12aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2665e32dba32044036fa66303c12aa">&#9670;&#160;</a></span>is_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Descriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool refl::descriptor::is_type </td>
          <td>(</td>
          <td class="paramtype">Descriptor&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether T is a type descriptor.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="classrefl_1_1descriptor_1_1type__descriptor.html">refl::descriptor::type_descriptor</a></dd></dl>
<div class="fragment"><div class="line">REFL_AUTO(type(Foo))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#abe2665e32dba32044036fa66303c12aa">is_type</a>(reflect&lt;Foo&gt;&gt;()) -&gt; <span class="keyword">true</span></div>
<div class="ttc" id="anamespacerefl_1_1descriptor_html_abe2665e32dba32044036fa66303c12aa"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#abe2665e32dba32044036fa66303c12aa">refl::descriptor::is_type</a></div><div class="ttdeci">constexpr bool is_type(Descriptor) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="refl_8hpp_source.html#l03007">refl.hpp:3007</a></div></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03007">3007</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3008</span>        {</div>
<div class="line"><span class="lineno"> 3009</span>            <span class="keyword">static_assert</span>(trait::is_descriptor_v&lt;Descriptor&gt;);</div>
<div class="line"><span class="lineno"> 3010</span>            <span class="keywordflow">return</span> trait::is_type_v&lt;Descriptor&gt;;</div>
<div class="line"><span class="lineno"> 3011</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a925e8cb99d6199fe03edeb5109958f8d" name="a925e8cb99d6199fe03edeb5109958f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925e8cb99d6199fe03edeb5109958f8d">&#9670;&#160;</a></span>is_writable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemberDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool refl::descriptor::is_writable </td>
          <td>(</td>
          <td class="paramtype">MemberDescriptor&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if T is a 1-arg non-const-qualified member function with a property attribute or a non-const field.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>User { std::string <a class="code hl_function" href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">get_name</a>() <span class="keyword">const</span>; }</div>
<div class="line">REFL_AUTO(type(User), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(<a class="code hl_function" href="namespacerefl_1_1descriptor.html#aff945ef69bf77ab1725a5a8d4c1fea98">get_name</a>, property()), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(set_name, property()))</div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a925e8cb99d6199fe03edeb5109958f8d">is_writable</a>(get_t&lt;0, <a class="code hl_typedef" href="namespacerefl_1_1descriptor.html#a50b88518840c2acd134a2171795bd7c3">member_list</a>&lt;User&gt;&gt;{}) -&gt; <span class="keyword">false</span></div>
<div class="line"><a class="code hl_function" href="namespacerefl_1_1descriptor.html#a925e8cb99d6199fe03edeb5109958f8d">is_writable</a>(get_t&lt;1, member_list&lt;User&gt;&gt;{}) -&gt; true</div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l03156">3156</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 3157</span>        {</div>
<div class="line"><span class="lineno"> 3158</span>            <span class="keyword">static_assert</span>(trait::is_member_v&lt;MemberDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 3159</span>            <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (trait::is_property_v&lt;MemberDescriptor&gt;) {</div>
<div class="line"><span class="lineno"> 3160</span>                <span class="keywordflow">return</span> std::is_invocable_v&lt;MemberDescriptor, typename MemberDescriptor::declaring_type&amp;, detail::placeholder&gt;;</div>
<div class="line"><span class="lineno"> 3161</span>            }</div>
<div class="line"><span class="lineno"> 3162</span>            <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (trait::is_field_v&lt;MemberDescriptor&gt;) {</div>
<div class="line"><span class="lineno"> 3163</span>                <span class="keywordflow">return</span> !std::is_const_v&lt;typename trait::remove_qualifiers_t&lt;MemberDescriptor&gt;::value_type&gt;;</div>
<div class="line"><span class="lineno"> 3164</span>            }</div>
<div class="line"><span class="lineno"> 3165</span>            <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3166</span>                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 3167</span>            }</div>
<div class="line"><span class="lineno"> 3168</span>        }</div>
</div><!-- fragment -->
<p class="reference">参照元 <a class="el" href="refl_8hpp_source.html#l03569">get_writer()</a>, <a class="el" href="refl_8hpp_source.html#l03479">has_writer()</a>, <a class="el" href="refl_8hpp_source.html#l03313">refl::descriptor::detail::normalize_accessor_name()</a>.</p>
<div class="dynheader">
被呼び出し関係図:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacerefl_1_1descriptor_a925e8cb99d6199fe03edeb5109958f8d_icgraph.svg" width="1235" height="328"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1a0a7b34d1892fffb8355aaeff29c750" name="a1a0a7b34d1892fffb8355aaeff29c750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0a7b34d1892fffb8355aaeff29c750">&#9670;&#160;</a></span>resolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer , typename FunctionDescriptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto refl::descriptor::resolve </td>
          <td>(</td>
          <td class="paramtype">FunctionDescriptor&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resolves the function pointer as a pointer of the specified type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">void</span> bar();</div>
<div class="line">  <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>);</div>
<div class="line">};</div>
<div class="line">REFL_AUTO(type(Foo), <a class="code hl_function" href="group__group1.html#ga24f647174760cac13d2624b5ad74b00c">func</a>(bar))</div>
<div class="line">resolve&lt;void(Foo::*)()&gt;(get_t&lt;0, member_list&lt;Foo&gt;&gt;()) -&gt; &lt;&amp;Foo::bar()&gt;</div>
<div class="line">resolve&lt;void(Foo::*)(int)&gt;(get_t&lt;0, member_list&lt;Foo&gt;&gt;()) -&gt; &lt;&amp;Foo::bar(<span class="keywordtype">int</span>)&gt;</div>
<div class="line">resolve&lt;void(Foo::*)(std::string)&gt;(get_t&lt;0, member_list&lt;Foo&gt;&gt;()) -&gt; <span class="keyword">nullptr</span></div>
</div><!-- fragment --> 
<p class="definition"> <a class="el" href="refl_8hpp_source.html">refl.hpp</a> の <a class="el" href="refl_8hpp_source.html#l02954">2954</a> 行目に定義があります。</p>
<div class="fragment"><div class="line"><span class="lineno"> 2955</span>        {</div>
<div class="line"><span class="lineno"> 2956</span>            <span class="keyword">static_assert</span>(trait::is_function_v&lt;FunctionDescriptor&gt;);</div>
<div class="line"><span class="lineno"> 2957</span>            <span class="keywordflow">return</span> d.template resolve&lt;Pointer&gt;();</div>
<div class="line"><span class="lineno"> 2958</span>        }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerefl.html">refl</a></li><li class="navelem"><a class="el" href="namespacerefl_1_1descriptor.html">descriptor</a></li>
    <li class="footer">構築: <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
